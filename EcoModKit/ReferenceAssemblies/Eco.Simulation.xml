<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eco.Simulation</name>
    </assembly>
    <members>
        <member name="P:Eco.Simulation.Agents.Organism.BornTime">
            <summary> Born time in <see cref="P:Eco.Simulation.Time.WorldTime.Seconds"/>. </summary>
        </member>
        <member name="P:Eco.Simulation.Agents.Organism.WorldHomePos">
            <summary>Home position is a position where it was spawned by simulation, it may be different from Position if Organism moved</summary>
        </member>
        <member name="M:Eco.Simulation.Agents.Plant.TrySeed(System.Double)">
            <summary> If possible, returns collection of position where plant leave the seeds. Can seed only once in SeedingTime. </summary>
        </member>
        <member name="P:Eco.Simulation.Agents.Tree.WorldHomePos">
            <inheritdoc cref="P:Eco.Simulation.Agents.Organism.WorldHomePos"/>
        </member>
        <member name="M:Eco.Simulation.Agents.Tree.RecreateBranches">
            <summary>Recreates tree branches. Intended for migrations and testing scenarios.</summary>
        </member>
        <member name="M:Eco.Simulation.Agents.Tree.FellTree(Eco.Shared.Networking.INetObject)">
            <summary> Base method to execute tree fall sequence. On Base abstract tree its regular destroy </summary>
        </member>
        <member name="M:Eco.Simulation.Agents.AI.GridUtils.DrawLine(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary> Fast Voxel Traversal Algorithm (Based on Bresenham's line algorithm). Uses trigonometry in comparing to grid traversal algorithm. http://www.cse.yorku.ca/~amana/research/grid.pdf </summary>
        </member>
        <member name="M:Eco.Simulation.Agents.AI.GridUtils.GridTraverse(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,System.Func{Eco.Shared.Math.Vector2i,System.Boolean})">
            <summary> Grid traversal algorithm based on bresenham's algorithm. Iterates through all 2d cells along a line. Returns
            true if all visits return true.</summary>
        </member>
        <member name="M:Eco.Simulation.Agents.AI.GridUtils.FastVoxelTraversal(System.Numerics.Vector3,System.Numerics.Vector3,System.Func{Eco.Shared.Math.Vector3i,System.Boolean})">
            <summary>>Return all voxels that are visited by a ray going from <param name="start" /> to <param name="end" /> by J. Amanatides, A. Woo. A Fast Voxel Traversal Algorithm for Ray Tracing. Eurographics '87.  http://www.cse.yorku.ca/~amana/research/grid.pdf
            We are following the equation {u} +t{v} (it represents a ray).
            General idea:
            1: initialize phase begins with identifying the voxel where the ray begins, find if our ray (by each axis) is incremented or decremented (step sign).
            Then we define t value - where the ray crosses the first voxel boundary (in each axis diraction).
            And compute delta for each axis direction - how far in units of t we should follow along the ray to make this distance be equal to width of a voxel (1 in our case).</summary>
            2: incremental phase: minimum of t in each direction will define in which direction we can go one step more and still be inside a voxel. Then move (by incrementing deltas) and repeat.
        </member>
        <member name="M:Eco.Simulation.Agents.AI.GridUtils.BruteForceLine(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,System.Single)">
            <summary> Slow grid-traverse algorithm for finding path from start to end point </summary>
        </member>
        <member name="M:Eco.Simulation.Agents.Animal.TryDamageByAnimal(System.Single)">
            <summary>When an animal damages another.</summary>
        </member>
        <member name="T:Eco.Simulation.Agents.ICanTakeDamage">
            <summary> Interface to be implemented by objects which can take damage. It then may be used in simulation (in example for attacking animals). </summary>
        </member>
        <member name="M:Eco.Simulation.Agents.ICanTakeDamage.TryDamage(Eco.Shared.Networking.INetObject,System.Single,Eco.Shared.SharedTypes.DamageSourceType)">
            <summary> Tries to make <paramref name="damage"/>. Returns <c>false</c> if failed to make any damage. </summary>
        </member>
        <member name="T:Eco.Simulation.Agents.IAnimalUtils">
            <summary> Injector interface to communicate between Simulation and Gameplay namespace. Or in most cases get Gameplay data into Simulation, liek rooms, etc. </summary>
        </member>
        <member name="M:Eco.Simulation.AnimalSim.SpawnAnimal(Eco.Simulation.Types.AnimalSpecies,System.Numerics.Vector3,System.Int32,System.Action{Eco.Simulation.Agents.Animal})">
            <summary>
            Spawn alive animal from <paramref name="species"/> at <paramref name="pos"/>.
            Optionally <paramref name="onCreate"/> action may be provided which will be called **before** animal registered as tickable.
            It ensures animal fully initialized before first tick.
            </summary>
        </member>
        <member name="M:Eco.Simulation.AnimalSim.SpawnCorpse(Eco.Simulation.Types.AnimalSpecies,System.Numerics.Vector3,System.Int32)">
            <summary> Spawn animal's corpse from <paramref name="species"/> at <paramref name="pos"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.AnimalSim.SpawnAnimalInternal(Eco.Simulation.Types.AnimalSpecies,System.Numerics.Vector3,System.Action{Eco.Simulation.Agents.Animal},System.Boolean,System.Int32)">
            <summary> Spawn animal corpse from <paramref name="species"/> at <paramref name="pos"/> either alive or it's <paramref name="corpse"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.Animals.AnimalPositionUtils.TryAdjustDeathPosition(System.Numerics.Vector3)">
            <summary> Corrects death pos  that can be gotten from current server val or requested from client in async mode (if needed) Goal: Make sure animal dies not in air.</summary>
        </member>
        <member name="M:Eco.Simulation.Animals.AnimalPositionUtils.UpdatePosFromController(Eco.Simulation.Agents.Animal,System.Func{System.Numerics.Vector3,System.Numerics.Vector3})">
            <summary> Asks the controlling player for the current position of the animal, if there is a controlling player.</summary>
        </member>
        <member name="F:Eco.Simulation.Animals.AnimalsManager.AnimalPopulationReducedEvent">
            <summary>Event triggered when animal population is reduced due to hunting. Arguments: (animal, hunter, worldPos, oldPopulation, newPopulation)</summary>
        </member>
        <member name="M:Eco.Simulation.Animals.AnimalsManager.OnAnimalHunted(Eco.Simulation.Agents.Animal,Eco.Shared.Networking.INetObject)">
            <summary>Handler for when an animal is hunted/killed - reduces population in world layer and checks for extinction</summary>
        </member>
        <member name="M:Eco.Simulation.Animals.AnimalsManager.OnAnimalPopulationChanged(System.String,System.Single,System.Single)">
            <summary>Event handler for animal population changes - checks for extinctions and recovery</summary>
        </member>
        <member name="M:Eco.Simulation.Animals.AnimalsManager.CheckSpeciesExtinction(Eco.Simulation.Types.AnimalSpecies,Eco.Shared.Networking.INetObject)">
            <summary>Unified extinction check - triggers if species population is 0 and not already marked extinct</summary>
        </member>
        <member name="M:Eco.Simulation.Animals.AnimalsManager.GetDisplayText">
            <summary> Gets state info for plugin manager </summary>
        </member>
        <member name="M:Eco.Simulation.ClimateState.PerDay(System.Single)">
            <summary> Calculates per day PPM for <paramref name="lastTickValue"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.ClimateState.PerHour(System.Single)">
            <summary> Calculates per hour PPM for <paramref name="lastTickValue"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.ClimateState.AppendCO2Emission(Eco.Shared.Localization.LocStringBuilder,Eco.Shared.Localization.LocString,System.Single,System.Single)">
            <summary> Appends line for CO2 emission. </summary>
        </member>
        <member name="M:Eco.Simulation.ClimateState.AppendTo(Eco.Shared.Localization.LocStringBuilder)">
            <summary> Appends state to <see cref="T:Eco.Shared.Localization.LocStringBuilder"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.ClimateState.ToLocString">
            <summary> Returns <see cref="T:Eco.Shared.Localization.LocString"/> representation of Climate State. </summary>
        </member>
        <member name="P:Eco.Simulation.ClimateSim.AirPollution">
            <summary> Accumulates air pollution in tons. </summary>
        </member>
        <member name="E:Eco.Simulation.ClimateSim.ClimateStateChanged">
            <summary> Can subscribe to this event for climate state updates. </summary>
        </member>
        <member name="M:Eco.Simulation.ClimateSim.Pull">
            <summary> Pulls data at beginning of tick for more precise results. </summary>
        </member>
        <member name="M:Eco.Simulation.ClimateSim.AddAirPollutionTons(Eco.Shared.Math.WrappedPosition3i,System.Single)">
            <summary> Adds <paramref name="tons"/> of air pollution at <paramref name="pos"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.EcoSim.WithTempEcoSim(Eco.Simulation.Settings.EcoDef,System.Action)">
            <summary>
            Creates temporary EcoSim singleton only with configuration. Intention is primary for unit testing.
            </summary>
            <param name="ecoDef">EcoDef config.</param>
            <param name="action">action to be executed with TempEcoSim.</param>
        </member>
        <member name="T:Eco.Simulation.Pathfinding.Internal.PackedPathNode">
            <summary>Stores the types of transitions to all 8 neighbors</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PackedPathNode.#ctor(Eco.Shared.Math.WorldPosition3i)">
            <summary>Create a packed node, querying the world around it to determine the movabilities in each direction.</summary>
            <param name="pos"></param>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PackedPathNode.GetPosForDir(Eco.Shared.Math.WorldPosition3i,Eco.Shared.Math.HorzDir)">
            <summary>Traverse in the given direction, if possible and return the position and movability.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PackedPathNode.Flatness">
            <summary>Returns number of transitions that aren't walk. 0 means totally flat, 8 means least possible flat.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PackedPathNode.GetNeighbors(Eco.Shared.Math.WorldPosition3i)">
            <summary>Returns all valid neighbors for this node at the given position.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PackedPathNodeExtensions.IsOpen(Eco.Shared.Math.WorldPosition3i)">
            <summary>Returns true if the block counts as empty for purposes of pathing.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PathFactory.Initialize(System.Collections.Generic.Dictionary{Eco.Shared.Math.WorldPosition3i,Eco.Simulation.Pathfinding.Internal.PackedPathNode},Eco.Simulation.Pathfinding.Internal.PathRegionSet[])">
            <summary>Builds the nodes and regions.</summary>
        </member>
        <member name="F:Eco.Simulation.Pathfinding.Internal.PathFactory.RequiredFlatness">
            <summary>This number sets the max number of non-walk connections allowed on a neighbor before it cant be a big-jump.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PathFinder.RandomWalkInDirection(Eco.Shared.Math.WorldPosition3i,System.Numerics.Vector3,System.Single,System.Single,Eco.Simulation.Pathfinding.Internal.PathRegion,Eco.Simulation.Types.AnimalSpecies)">
            <summary>
            Finds a target position by doing a random walk exploration from the starting point in the given direction,
            then returns the optimal path to that target position.
            </summary>
        </member>
        <member name="T:Eco.Simulation.Pathfinding.Internal.PathfindUtil">
            <summary>Utility methods for pathfinding operations.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PathfindUtil.SelectFromTopCandidates(System.Collections.Generic.List{System.ValueTuple{Eco.Shared.Math.WorldPosition3i,System.Single}})">
            <summary>
            Efficiently selects a position from candidates by finding the top 3 scoring candidates
            and randomly picking from them. This provides good direction bias while maintaining
            some randomness for natural movement.
            </summary>
            <param name="candidates">List of candidates with their scores</param>
            <returns>The selected position</returns>
        </member>
        <member name="T:Eco.Simulation.Pathfinding.Internal.PathRegion">
            <summary>Defines a region, which is a connected set of positions which can all be reached from each other.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PathRegion.FillNeighbors(Eco.Simulation.Pathfinding.Internal.PackedPathNode,Eco.Shared.Math.WorldPosition3i,System.Span{Eco.Shared.Math.WorldPosition3i})">
            <summary>For debugging, can get all the valid neighbors from a given node and pos.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PathRegion.GetRandomPosition(Eco.Shared.Math.WorldPosition3i,System.Numerics.Vector3,System.Single,System.Single,Eco.Shared.Items.PathfindFlags,System.Func{Eco.Shared.Math.WorldPosition3i,System.Boolean},System.Single)">
            <summary>Finds a random position, checking up to 100 points, that is in the given direction within 90 degrees, and is the given distance.  If dir is zero, ignore. Filterfunc can block points from being considered.  After 100, the filter is ignored.</summary>
        </member>
        <member name="T:Eco.Simulation.Pathfinding.Internal.PathRegionSet">
            <summary>Defines a set of path regions of the same type.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PathRegionSet.GetRegionAt(System.Numerics.Vector3,System.Boolean,System.Boolean)">
            <summary>Get the region at the given position, +/- 1 Y</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.Internal.PathRegionSet.UpdateNodeConnectivity(Eco.Shared.Math.WorldPosition3i,Eco.Shared.Math.WorldPosition3i,Eco.Simulation.Pathfinding.Internal.PackedPathNode)">
            <summary>Dirty all regions that had this position.</summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.PathManager.ManualUpdate">
            <summary> Calls full update on blocks and regions (forced). Useful when there are big changes like from commands and needs immediate update </summary>
        </member>
        <member name="M:Eco.Simulation.Pathfinding.PathManager.GetDisplayText">
            <summary> Gets state info for plugin manager </summary>
        </member>
        <member name="T:Eco.Simulation.Plants.PlantCache">
            <summary> This clase provides access to plants by species acording cell size. It allows fast lookup by area and plant species for most cases. 
            Internally it saves plants in cells of diferent sizes: by example 0-5, 5-10 and 0-10. It helps to be able provide fast access for areas of diferent sizes: in case if area match some cell, it can just return data inside of it.
            </summary>
        </member>
        <member name="F:Eco.Simulation.Plants.PlantCache.plantByAreaByCellSize">
            Cells have HashSet in order to avoid allocations, so the editing and access must happen through locking.
        </member>
        <member name="M:Eco.Simulation.Plants.PlantCache.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Accepts an enumerable of cell sizes that will be saved in the cache. Something like 5,10,20,40 should cover most requests. 
            It will represent the cell sizes in which it saves the data, by example for 5, 10 it will save plants in cells 0-5, 5-10, 0-10. </summary>
        </member>
        <member name="M:Eco.Simulation.Plants.PlantCache.EnumerableOfArea(Eco.Shared.Math.WorldArea,Eco.Simulation.Types.PlantSpecies)">
            <summary> Use this as low-memory allocation option for iterating over plants in area. Internally it will use a lock and pooled list to get plants and release the pooled list in the end of iteration. 
            Can be used with linq methods, like Sum </summary>
        </member>
        <member name="M:Eco.Simulation.Plants.PlantCache.AddPlant(Eco.Simulation.Agents.Plant)">
            <summary> Adds plant to all cells that match it, by example position 4 would match cell 0-5, 0-10 and 0-20.
            It uses lock instead of thread-safe collection in order to sacrify a little performance but have gain in less memory allocations. </summary>
        </member>
        <member name="M:Eco.Simulation.Plants.PlantCache.RemovePlant(Eco.Simulation.Agents.Plant)">
            <summary> Removes plant from all cells that match it. As AddPlant, it uses lock aproach instead of thread-safe collections. </summary>
        </member>
        <member name="M:Eco.Simulation.Plants.PlantCache.CollectPlantsInArea(Eco.Shared.Math.WorldArea,Eco.Shared.Pools.Collections.PoolableListWrapper{Eco.Simulation.Agents.Plant},Eco.Simulation.Types.PlantSpecies)">
            <summary> Entry method to cache. Area may match or not internal cells, it will automaticly make all transformations requiered, the area can be not-wraped.  </summary>
        </member>
        <member name="M:Eco.Simulation.Plants.PlantCache.CollectPlantsInWrappedArea(Eco.Shared.Math.WorldArea,Eco.Shared.Pools.Collections.PoolableListWrapper{Eco.Simulation.Agents.Plant},Eco.Simulation.Types.PlantSpecies)">
            <summary> This will split area if don't match the cell sizes: it can split area 4-8 to check cells 0-5, 5-10. </summary>
        </member>
        <member name="M:Eco.Simulation.Plants.PlantCache.CollectPlantsInCell(Eco.Shared.Math.Vector2i,System.Int32,Eco.Shared.Pools.Collections.PoolableListWrapper{Eco.Simulation.Agents.Plant},Eco.Simulation.Types.PlantSpecies,System.Nullable{Eco.Shared.Math.WorldArea})">
            <summary> Pass area if check area.Contains(Plant.position) is needed. Its requeired if area don't match cells: by example having cells 0-5, 5-10, but the area is 3-5.</summary>
        </member>
        <member name="T:Eco.Simulation.Plants.PlantsInAreaEnumerable">
            <summary> Allows to iterate through plants in area with almost no memory alloactions by using poolablelist inside of enumerator </summary>
        </member>
        <member name="T:Eco.Simulation.Plants.PlantsInAreaEnumerableExtensions">
            <summary> Allows to use Enumerable.AsValueEnumerable without boxing. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Internal.PlantGrouper">
            <summary> This class creates groups of plants when world is generating. It allows to group them into two levels:
            1) Clusters. Big circle in the world defined via % of world size. Attempted to have gameplay value by limiting recourses to some areas. 
            2) Plant groups. Mostly for visuals, so plants will look logically grouped. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Internal.PlantGrouper.ShouldBeSpanwedAsAGroup(Eco.Simulation.Types.PlantSpecies)">
            <summary> This function should be use to decide if plant will be spawned in group or not. It spawns in groups only at world generation phase, after that plants already will be statistically tend to group because of reproduction near already existing species.  </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Internal.PlantGrouper.TryAddPlantToTheGroup(Eco.Simulation.Types.PlantSpecies,Eco.Shared.Math.Vector2i)">
            <summary> If there are any group of plants close enough it will add them to the group and remove the free spot from group. If there are no such group, it will return false. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Internal.PlantGrouper.Initialize">
            <summary> Generates clusters and groups, edits layer values. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Internal.PlantGrouper.TryAddGroup(Eco.Simulation.Types.PlantSpecies,Eco.Shared.Math.Vector2i,System.Collections.Generic.List{Eco.Simulation.WorldLayers.Internal.PlantGrouper.PlantGroup},System.Single)">
            <summary> Checks if its possible to add a new group of plants to specific position. It's possible if there are no group too close to it. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Internal.PlantGrouper.Cluster">
            <summary> Represents some big area of the world where plant will be spawned. It matters only at world generation. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Internal.PlantGrouper.PlantGroup">
            <summary> Represents a particular small group of plants. Like 5 tomatoes growing each next to other. Its used mostly for visual grouping so similar plants spawned near. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Pullers.PlantSpreader">
            <summary> Populates values of Seeds for plants.
            Seeds works this way: every tick plants tries to send seed in base of internal timer in some range from them. 
            This seeds will be used to increase the population layer. 
            </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Pullers.PlantPopulationPuller">
            <summary> Special kind of IStartupWorldLayerPuller which tracks added/removed plants between ticks and apply changes when tick happens. It also sync layer with actual plants count on startup. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pullers.PlantPopulationPuller.PopulationDelta(Eco.Shared.Math.WorldArea)">
            <summary> Returns population delta for current added/remove plants snapshot. It will be negative value if removed plants more than added and positive otherwise. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pullers.PlantPopulationPuller.GetStartupValue(Eco.Shared.Math.Vector2i,Eco.Shared.Math.WorldArea)">
            <summary> On startup ensures world plants count and layer plants count synced. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Pullers.PlantPopulationPuller.PlantInAreaFilter">
            <summary>Function which checks if plant belongs to a specific area. Uses with NetFabric.Hyperlinq for zero-allocation filters.</summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.AccumulatingPuller">
            <summary>
            A puller that accumulates layer modifications that occur between worldlayer ticks, typically as a result of WorldObject and player actions.
            Use it as a proxy for writing directly to a layer.
            </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Components.BiomeComponent">
            <summary>
            Used by <see cref="T:Eco.Simulation.WorldLayers.Pushers.BiomePusher"/> to set terrain blocks.
            </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.DebrisCache">
            <summary> Caches information about tree debris presence in the world. Used in plant and trampling simulation. </summary>
        </member>
        <member name="P:Eco.Simulation.WorldLayers.DebrisCache.Cache">
            <summary> Cache contains mapping between X,Z and Y of tree debris. It only supports one tree debris in a column which should be fine in 99.999% cases and we don't need 100% precision here. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.DebrisCache.Flush">
            <summary> Flushes queued block changes and actualizes cache state. </summary>
        </member>
        <member name="F:Eco.Simulation.WorldLayers.Editor.WorldLayerButtons.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Editor.WorldLayerButtons.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Editor.WorldLayerButtons.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.History.GifEncoder">
            <summary>
            Encodes multiple images as an animated gif to a stream. <br />
            ALWAYS ALWAYS ALWAYS wire this up   in a using block <br />
            Disposing the encoder will complete the file. <br />
            Uses default .net GIF encoding and adds animation headers.
            </summary>
            Modified gifencoder from https://github.com/DataDink/Bumpkit
        </member>
        <member name="M:Eco.Simulation.WorldLayers.History.GifEncoder.#ctor(System.IO.Stream,System.Nullable{System.Int32})">
            Encodes multiple images as an animated gif to a stream.
            ALWAYS ALWAYS ALWAYS wire this in a using block
            Disposing the encoder will complete the file.
            Uses default .net GIF encoding and adds animation headers.
            <param name="stream">The stream that will be written to.</param>
            <param name="repeatCount">Sets the repeat count for this gif or null to use default.</param>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.History.GifEncoder.AddFrame(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{System.TimeSpan})">
            <summary>
            Adds a frame to this animation.
            </summary>
            <param name="frame">The frame byte array to add.</param>
            <param name="colorTable">The color table byte array.</param>
            <param name="width">Sets the width for this gif or null to use the first frame's width.</param>
            <param name="height">Sets the height for this gif or null to use the first frame's height.</param>
            <param name="x">The positioning x offset this image should be displayed at.</param>
            <param name="y">The positioning y offset this image should be displayed at.</param>
            <param name="frameDelay">The frame delay or null for default.</param>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.IPostWorldGenWorldLayerPusher">
            <summary>
            Interface for pushers who aware about post world gen (after all interactions initialized, but before Tick).
            If pusher may modify layer values (like Plant Spawner which checks actually available spawn blocks and also ensures to not spawn plants over capacity) then you may need
            to have this callback so interaction during Tick phase will use adjusted values (i.e. for consumed capacity calculation).
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.IPostWorldGenWorldLayerPusher.PostWorldGenPush(Eco.Shared.Math.WorldArea,System.Single[],Eco.Simulation.WorldLayers.WorldLayerNeighborInfo[],System.Int32)">
            <summary> Method which invoked after all interaction initialized, but before <see cref="M:Eco.Simulation.WorldLayers.NewWorldLayerSync.Tick"/> on PostWorldGen stage. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.IStartupWorldLayerPuller">
            <summary> Interface extending <see cref="T:Eco.Simulation.WorldLayers.IWorldLayerPuller"/> with ApplyStartupValue which pulls startup value based on current world state. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.LayerInteractions.EnvironmentInteractions.ApplyTrample(Eco.Shared.Math.Vector3i,System.Single)">
            <summary>Apply a given amount of time trample at a location.</summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.LayerInteractions.PlantInteraction`1">
            <summary> Base class for Plant interactions. Contains common methods. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.LayerInteractions.PlantInteraction`1.ApplyResourceConstraints(System.Single@,System.String@,System.Single[])">
            <summary> Applies resource limit to current limit modifier. </summary>
            <param name="habitability">Current limit modifier [0; 1]. May be reduced if restricted by resources.</param>
            <param name="layerName">Restricting layer name if any layer reduced limit.</param>
            <param name="dependencyValues">Dependency values for calculations.</param>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.LayerInteractions.PlantInteraction`1.ApplyCapacityConstraints(System.Single@,System.String@,System.Single[])">
            <summary>
            Applies capacity constraints to <paramref name="availablePopulationExtension"/>.
            It uses two layers {Plant}Capacity and {Plant}ConsumedCapacity for calculation.
            For every plant there may be few capacity constraints like required fertile ground per plant and required canopy space per plant.
            Then it calculates how plants may be planted in available capacity (total - consumed) and reduces <paramref name="availablePopulationExtension"/> if it is greater than the value.
            After applying these constraints it ensures that layer value is capped by all capacities (can't be increased more than for updated <paramref name="availablePopulationExtension"/>).
            </summary>
            <param name="availablePopulationExtension">Currently available population extension.</param>
            <param name="layerName">Restricting layer name if any layer reduced limit.</param>
            <param name="dependencyValues">Dependency values for calculations.</param>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.LayerInteractions.PlantPopulationConsumedCapacityInteraction">
            <summary>
            This interaction used by plant species to update consumed capacity in capacity layers. It inherits from <see cref="T:Eco.Simulation.WorldLayers.LayerInteractions.ProportionalInteraction"/>,
            but ensures only fully spawned plants consumed capacity to avoid situation with overcrowding and non-spawning from fractional plants.
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.LayerInteractions.PlantPopulationConsumedCapacityInteraction.GetValue(System.Single[])">
            <summary> Trim to integer number of plants to avoid consume capacity for fractional plants which may prevent plants from grow and spawn. </summary>
        </member>
        <member name="P:Eco.Simulation.WorldLayers.LayerInteractions.ProducerSpeciesGrowth.RequiresNeighborhood">
            <inheritdoc cref="P:Eco.Simulation.WorldLayers.WorldLayerInteraction`1.RequiresNeighborhood"/>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.LayerInteractions.ProducerSpeciesGrowth.ConstrainedGrowthValue(System.Single,System.Single[])">
            <summary> Overload for <see cref="M:Eco.Simulation.WorldLayers.LayerInteractions.ProducerSpeciesGrowth.ConstrainedGrowthValue(System.Single,System.Single[],System.Single@,System.String@)"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.LayerInteractions.ProducerSpeciesGrowth.ConstrainedGrowthValue(System.Single,System.Single[],System.Single@,System.String@)">
            <summary> Calculates growth value between <code>-currentValue</code> and <code>1 - currentValue</code> depending on habitability. Negative value limited to <see cref="P:Eco.Simulation.Types.PlantSpecies.MaxDeathRate"/> and positive limited by <see cref="P:Eco.Simulation.Types.PlantSpecies.MaxGrowthRate"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.LayerInteractions.ProducerSpeciesGrowth.PostWorldgenHabitability(System.Single[])">
            <summary> Calculated initial PostWorldGen habitability for initial plants population. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.LayerInteractions.ProportionalInteraction.GetValue(System.Single[])">
            <summary> Returns value which will be used for proportion calculation. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.LayerInteractions.SecondOrderReaction">
             <summary>
             Simulates a differential equation of the form dz/dt = c * x * y.
             This is the same math as is used to describe a second-order chemical reaction, so I've elected to adopt that terminology.
             It should be an apt analogy for every use of this interaction - acid rain happens when air pollution meets rain; predation happens when predator meets prey; etc.
            
             N.B. this class, like all WorldLayerInteractions, does not modify the input layers.
             In chemical terms, the inputs are both catalysts by default - they are not affected by the reaction.
             If you wish an input to be affected, create another instance of SecondOrderReaction that has that input as its product.
             </summary>
        </member>
        <member name="F:Eco.Simulation.WorldLayers.Layers.AnimalLayer.PopulationTickChangedEvent">
            <summary>Event triggered when animal layer population changes after a tick. Arguments: (layerName, populationBefore, populationAfter)</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.AnimalLayer.OnServerStart">
            <summary> Callback to be invoked once when server started while <see cref="M:Eco.Simulation.WorldLayers.Layers.AnimalLayer.InitSelf"/> only called once when <see cref="T:Eco.Simulation.WorldLayers.Layers.AnimalLayer"/> created. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.AnimalLayer.TickPopulation(Eco.Shared.Math.Vector2i,System.Single)">
            <summary>
            Ticks animal species population for one <see cref="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.Tick"/>.
            It applies changes to population (like killed animals), simulates population growth and spread from neighbor cells.
            Population will only grow if there at least one animal (assuming it was pregnant) and only spread from neighbor cells with at least one organism.
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.AnimalLayer.InitSelf">
            <summary> Set initial layer values. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.AnimalLayer.MaxPop(Eco.Shared.Math.Vector2i)">
            <summary> Maximal population in <paramref name="layerPos"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.AnimalLayer.BackwardsCompatibilityCheck">
            <summary> Checks if layer dimensions was changed and re-generated layer in this case. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Layers.LayerPosition">
            <summary> Struct which holds both <see cref="F:Eco.Simulation.WorldLayers.Layers.LayerPosition.Position"/> and <see cref="F:Eco.Simulation.WorldLayers.Layers.LayerPosition.VoxelsPerEntry"/> so may be used with any layer which will translate own value to requested layer position granularity. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.LayerPosition.FromWorldPosition(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary> Creates <see cref="T:Eco.Simulation.WorldLayers.Layers.LayerPosition"/> from <paramref name="worldPosition"/> with specified <paramref name="voxelsPerEntry"/> granularity. </summary>
        </member>
        <member name="P:Eco.Simulation.WorldLayers.Layers.TemperatureLayerSettings.CelsiusRange">
            <summary> Temperature range in Celsius. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.TemperatureLayerSettings.GetDisplayValue(System.Single,System.Boolean)">
            <summary> Converts the temperature layer value to Celsius. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.TickFinished">
            <summary>Called after all layer ticks are complete and totals have been reset</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.FineToCoarse(Eco.Simulation.WorldLayers.Layers.LayerPosition)">
            <summary> Convert value from layer with finer granularity to layer with coarser granularity. I.e. for temperature layer with 5x5 granularity it will return average temperature of 4x4 temperature cells for Oak layer with 20x20 granularity. Value depends on layer's value type. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.CoarseToFine(Eco.Simulation.WorldLayers.Layers.LayerPosition)">
            <summary> Convert value from layer with coarser granularity to layer with finer granularity. I.e. when calculating consumed capacity (5x5 granularity) for trees with 20x20 granularity it will get same value for every consumed capacity cell within coarser tree cell. Value depends on layer's value type. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.TransformInArea(Eco.Shared.Math.WorldArea,System.Func{System.Single,System.Single})">
            <summary> Transforms value for each cell in the <paramref name="worldArea"/> using <paramref name="transform"/> function. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.GetValue(Eco.Simulation.WorldLayers.Layers.LayerPosition)">
            <summary> Gets the layer at <paramref name="layerPos"/>. If granularity different then will translate the value. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.TranslateEntryToAmount(Eco.Simulation.WorldLayers.Layers.WorldLayer,Eco.Shared.Math.Vector2i)">
            <summary>
            Query <paramref name="other"/> layer amount at <paramref name="layerPos"/>, translating when the other layer resolution is different. Result depends on other layer's <see cref="P:Eco.Simulation.WorldLayers.Layers.WorldLayerSettings.ValueType"/>.
            For <see cref="F:Eco.Simulation.WorldLayers.Layers.WorldLayerValueType.Amount"/> and <see cref="F:Eco.Simulation.WorldLayers.Layers.WorldLayerValueType.Percent"/> it will return unmodified value, but for <see cref="F:Eco.Simulation.WorldLayers.Layers.WorldLayerValueType.FillRate"/> it will return value multiplied by <see cref="P:Eco.Simulation.WorldLayers.Layers.WorldLayer.CellArea"/>.
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.PullStartupLayer(Eco.Simulation.WorldLayers.IStartupWorldLayerPuller)">
            <summary> Pulls startup value for layer using <paramref name="puller"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.ForEachCell(System.Int32,Eco.Simulation.WorldLayers.Layers.WorldLayer[],System.Action{Eco.Shared.Math.Vector2i,Eco.Shared.Math.WorldArea,System.Single[],Eco.Simulation.WorldLayers.WorldLayerNeighborInfo[],System.Int32})">
            <summary> Invokes <paramref name="action"/> for every cell with <paramref name="voxelsPerEntry"/> granularity with normalized values from <paramref name="dependencies"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.PushLayers(Eco.Simulation.WorldLayers.IWorldLayerPusher)">
            <summary> Push layers with <paramref name="pusher"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.LayerPosToWorldArea(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary> Converts <paramref name="layerPos"/> to <see cref="T:Eco.Shared.Math.WorldArea"/> with <paramref name="voxelsPerEntry"/> granularity. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.ValStringHtml(System.Single,System.Boolean)">
            <summary> Returns a string in HTML format for the <paramref name="val"/> using <see name="Settings"/>. Set <paramref name="relative"/> if you wanna to format value difference. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayer.ValStringTooltip(System.Single,System.Boolean)">
            <summary> Returns a tooltip string for the <paramref name="val"/> using <see name="Settings"/>. Set <paramref name="relative"/> if you wanna to format value difference. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayerSettingsExtensions.ValString(Eco.Simulation.WorldLayers.Layers.WorldLayerSettings,System.Single,System.Boolean,System.Boolean)">
            <summary> Returns formatted <paramref name="val"/> string in requested format using <paramref name="settings"/>. Set <paramref name="relative"/> if you wanna to format value difference. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayerSettingsExtensions.ValStringHtml(Eco.Simulation.WorldLayers.Layers.WorldLayerSettings,System.Single,System.Boolean)">
            <summary> Returns a string in HTML format for the <paramref name="val"/> using <paramref name="settings"/>. Set <paramref name="relative"/> if you wanna to format value difference. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayerSettingsExtensions.ValStringTooltip(Eco.Simulation.WorldLayers.Layers.WorldLayerSettings,System.Single,System.Boolean)">
            <summary> Returns a tooltip string for the <paramref name="val"/> using <paramref name="settings"/>. Set <paramref name="relative"/> if you wanna to format value difference. </summary>
        </member>
        <member name="P:Eco.Simulation.WorldLayers.Layers.WorldLayerSettings.OriginalDisplayName">
            <summary>
            Added to work around a website issue. Represents the original name as defined in the Eco mods directory. 
            Should be replaced with a real solution in 10.0
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Layers.WorldLayerSettings.GetDisplayValue(System.Single,System.Boolean)">
            <summary> Returns user-friendly representation (i.e. for temperature normalized value [0; 1] it may be value in Celsius). </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.WorldLayerNeighborInfo">
            <summary>
            This struct provides on demand values for all neighbor cells around the <see cref="F:Eco.Simulation.WorldLayers.WorldLayerNeighborInfo.cell"/> (3x3 matrix with the cell in the center).
            It may be used by interactions which requires neighbors info (i.e. for values spreading).
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerNeighborInfo.#ctor(Eco.Shared.Math.WorldArea,Eco.Simulation.WorldLayers.Layers.IWorldLayerView,System.Boolean)">
            <summary> Use <paramref name="poolArray"/> only in case if you are going to Dispose this object after using </summary>
        </member>
        <member name="P:Eco.Simulation.WorldLayers.WorldLayerNeighborInfo.Neighborhood">
            <summary> The values of the corresponding layer in the 8 adjacent layer cells (plus this center one).
            Arranged geometrically from least to most x and y, e.g. Neighborhood[0, 2] is the adjacent cell with a smaller x and a larger y coordinate.
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.NewWorldLayerSync.OnServerStart">
            <summary> Callback for the server statup. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.BiomePusher.ActionOnBiomeMismatches``1(Eco.Shared.Math.WorldArea,Eco.Simulation.WorldLayers.WorldLayerNeighborInfo[],``0,System.Action{System.Type,System.Type,Eco.Shared.Math.Vector3i,``0},System.Int32)">
            <summary>
            Check if the top block of each world column in an area is the same as the column biome.
            e.g. If we are in grasslands and there's a dirt block, there's a chance this block will become a grass block.
            This chance is calculated according to the neighbor blocks, so if there are many grass blocks around a dirt block, the chances of turning into grass will be higher.
            If the chance calculation is successful, <param name="mismatchAction"/> is called.
            </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.LayersInfo">
            <summary> Layers layout info for <see cref="T:Eco.Simulation.WorldLayers.Pushers.PlantSpawner"/> dependencies. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity">
            <summary>
            <see cref="T:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity"/> class holds information about available capacity for <see cref="F:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.LayerNames"/> with <see cref="F:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.VoxelsPerEntry"/> granularity.
            <see cref="F:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.AvailableCapacities"/> has flatten 2D array structure of [[availableCapacitiesPerLayerForCell1], [availableCapacitiesPerLayerForCell2], .., [availableCapacitiesPerLayerForCellN]].
            Each such cell is for <see cref="F:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.VoxelsPerEntry"/> dimension. In each cell it has LayerNames.Count entries one value per capacity layer with same index as in LayerNames.
            We need to have multiple cells in available capacities because of some plants like trees may use multiple capacity cells and should consume capacity from all of them evenly if possible.
            Small plants usually consume capacity only from one capacity cell.
            It is up to constructor calling code how to order cells, but usually it has Y groups of X size and offset of each cell may be calculated as (Y * xSize + X) * LayerNames.Count.
            Capacity may be consumed in two ways:
            <p>- Consume as much as possible with <see cref="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.Consume(Eco.Simulation.Types.PlantSpecies,System.Int32,System.Int32)"/>, it will ignore unconsumed capacity;</p>
            <p>- Either fully consume all requested capacities or not consume at all with <see cref="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.TryConsume(Eco.Simulation.Types.PlantSpecies,System.Int32,System.Int32)"/></p>
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.GetSliceSize(System.Int32)">
            <summary>Returns size of capacities slice for <paramref name="voxelsPerEntry"/> resolution. Calculated as <c>(voxelsPerEntry * voxelsPerEntry / cellArea) * LayerNames.Length</c>.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.GetSpeciesRange(Eco.Simulation.Types.PlantSpecies,System.Int32)">
            <summary>
            Returns range of capacity values for <paramref name="species"/> for given offset. Range calculated based on scale between species VoxelsPreEntry and capacity VoxelsPerEntry and offset.
            The offset may be calculated using <c>(Y * xSize + X) * LayerNames.Count</c> formula. (X,Y) is relative capacity cell position.
            If species voxel per entry is greater than capacity voxel per entry then it will be aligned to include the offset.
            Range length calculated with <see cref="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.GetSliceSize(System.Int32)"/> for species VoxelsPerEntry.
            </summary>
            <example>
            I.e. if we have 2 capacity layers, capacity VoxelsPerEntry is 5, species1 with VoxelPerEntry equal to 10, species2 with VoxelPerEntry equal to 5 and we have 2x2 capacity area (2*5x2*5=10x10 voxels) then
            <p>- for (0, 0) normalized offset will be 0 for both species1 and species2;</p>
            <p>- for (0, 1) normalized offset will be 0 for species1 and (0*2 + 1)*2 = 2 for species2;</p>
            <p>- for (1, 0) normalized offset will be 0 for species1 and (1*2 + 0)*2 = 4 for species2;</p>
            <p>- for (1, 1) normalized offset will be 0 for species1 and (1*2 + 1)*2 = 6 for species2;</p>
            </example>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.TryConsume(Eco.Simulation.Types.PlantSpecies,System.Int32,System.Int32)">
            <summary>Tries to consume (reduce) available capacity for <paramref name="count"/> of plant <paramref name="species"/>. Returns <c>true</c> if succeed. If failed then no modification to capacity happens.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.Consume(Eco.Simulation.Types.PlantSpecies,System.Int32,System.Int32)">
            <summary>Consumes as much as possible from <see cref="F:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.AvailableCapacities"/> for <paramref name="count"/> of plant <paramref name="species"/>. Consuming means that available capacity reduced by consumed capacity amount.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.ConsumeInternal(Eco.Simulation.Types.PlantSpecies,System.Int32,System.Span{System.Single})">
            <summary>Consumes from <see cref="F:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.AvailableCapacities"/> capacities required for the <paramref name="count"/> of <paramref name="species"/>. Returns <c>true</c> if enough <see cref="F:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.AvailableCapacities"/>.  Consuming means that available capacity reduced by consumed capacity amount.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.ConsumeCapacityForOneCell(Eco.Simulation.Types.PlantSpecies,System.Single,System.Span{System.Single})">
            <summary> Optimized version of <see cref="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity.Consume(Eco.Simulation.Types.PlantSpecies,System.Int32,System.Int32)"/> for one cell with same resolution as capacity. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.BuildLayersInfo">
            <summary> Builds <see cref="T:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.LayersInfo"/> which contains all info about dependency layers. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.SyncPlants(Eco.Simulation.WorldLayers.Pushers.PlantSpawner.LayersInfo,Eco.Shared.Math.WorldArea,System.Span{Eco.Simulation.WorldLayers.Layers.PlantLayer},Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity,System.Int32)">
            <summary>
            Synchronizes the plant layer values and the World plant counts in the <paramref name="area"/>.
            <paramref name="availableCapacity"/> contains capacities for <paramref name="area"/> and will be consumed by world plants, so after call you will have <paramref name="availableCapacity"/> for new plants.
            It returns desired plants to spawn as list of <see cref="T:Eco.Simulation.WorldLayers.Layers.PlantLayer"/>. It may have repeatable entries for multiple plants of same species.
            </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.GetLayerValues``1(System.Span{``0},Eco.Simulation.WorldLayers.Layers.LayerPosition,System.Span{System.Single})">
            <summary>For each layer in <paramref name="layers"/> saves value at <paramref name="layerPosition"/> to <paramref name="outputValues"/>.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.GetAvailableCapacities(Eco.Shared.Math.WorldArea,Eco.Simulation.WorldLayers.Pushers.PlantSpawner.LayersInfo)">
            <summary>Returns <see cref="T:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity"/> object with available capacities for <paramref name="area"/>. Capacity layers obtained from <paramref name="layersInfo"/>.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Apply(Eco.Shared.Math.WorldArea,System.Single[],Eco.Simulation.WorldLayers.WorldLayerNeighborInfo[],System.Int32)">
            <inheritdoc cref="M:Eco.Simulation.WorldLayers.IWorldLayerPusher.Apply(Eco.Shared.Math.WorldArea,System.Single[],Eco.Simulation.WorldLayers.WorldLayerNeighborInfo[],System.Int32)"/>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.SpawnPlantsInCellsOfDifferentSize(Eco.Simulation.WorldLayers.Pushers.PlantSpawner.LayersInfo,Eco.Shared.Math.WorldArea,System.ReadOnlySpan{System.ValueTuple{System.Int32,Eco.Simulation.WorldLayers.Layers.PlantLayer[]}},System.Collections.Generic.List{Eco.Simulation.WorldLayers.Layers.PlantLayer},Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity,System.Int32)">
            <summary>
            Spawns all plant groups from <paramref name="plantGroups"/> recursively. Plants grouped by voxelsPerEntry descending.
            If this is last plant group then it will just spawn plants with <see cref="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.SpawnPlantsInArea(Eco.Shared.Math.WorldArea,System.Collections.Generic.List{Eco.Simulation.WorldLayers.Layers.PlantLayer},Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity,System.Int32)"/>
            otherwise for each cell in the area for group granularity it calls <see cref="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.SpawnPlantsInCellsOfDifferentSize(Eco.Simulation.WorldLayers.Pushers.PlantSpawner.LayersInfo,Eco.Shared.Math.WorldArea,System.ReadOnlySpan{System.ValueTuple{System.Int32,Eco.Simulation.WorldLayers.Layers.PlantLayer[]}},System.Collections.Generic.List{Eco.Simulation.WorldLayers.Layers.PlantLayer},Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity,System.Int32)"/> with all plants from current group in <paramref name="spawnAtPos"/> list.
            This way it not only spawns nested group plants, but also spawns bigger granularity group plants in one of nested cells.
            </summary>
            <example>
            I.e. we have [(20, [Birch, Fir]), (5, [Corn, Tomato])] plant groups for (0,0)-(20,20) area.
            First call with all plant groups will have only one cell for the area because it is same size as the area.
            All trees to spawn collected for this cell. Assume there are [Birch, Birch, Fir].
            Then <see cref="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.SpawnPlantsInCellsOfDifferentSize(Eco.Simulation.WorldLayers.Pushers.PlantSpawner.LayersInfo,Eco.Shared.Math.WorldArea,System.ReadOnlySpan{System.ValueTuple{System.Int32,Eco.Simulation.WorldLayers.Layers.PlantLayer[]}},System.Collections.Generic.List{Eco.Simulation.WorldLayers.Layers.PlantLayer},Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity,System.Int32)"/> called with tailing plant groups: [(5, [Corn, Tomato])].
            Now, because voxelsPerEntry = 5, it will have 4 cells in the area: (0, 0), (0, 1), (1, 0) and (1, 1).
            For each cell it will have own list of plants to spawn like [Tomato, Tomato], [Corn, Corn], [Corn, Tomato], [].
            These list will be concatenated with [Birch, Birch, Fir] from previous plant group before spawn.
            So it may spawn [Birch, Tomato, Tomato] in first cell, then all not spawned trees ([Birch, Fir]) will be concatenated to next plant spawn list etc.
            This way trees will be mixed with small plants and distributed between all sub-cells.
            </example>
            <param name="layersInfo">Contains shared layers information like all constraint layers, min voxel size for normalization, trampled layer etc.</param>
            <param name="area">World area for spawning.</param>
            <param name="plantGroups">Plant groups to spawn. Each plant group is pair of (voxelsPerEntry, plantLayersInGroupArray) ordered by voxelsPerEntry descending.</param>
            <param name="spawnAtPos">Plants to spawn in the area. Contains all plants from previous group.</param>
            <param name="availableCapacities"><see cref="T:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity"/> object will non-consumed capacities. Updates every time when new plant added.</param>
            <param name="baseCapacityOffset">Offset for cell capacities. Used because of optimized flatten capacities structure where all cells capacities stored in one array.</param>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.TryFindGoodPlaceAndConsumeCapacity(Eco.Simulation.Types.PlantSpecies,System.Boolean,System.Collections.Generic.List{Eco.Shared.Math.Vector3i},System.Collections.Generic.List{Eco.Simulation.Agents.Tree},Eco.Simulation.WorldLayers.Pushers.PlantSpawner.Capacity,System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary> Checks both capacity and placement for <paramref name="plantSpecies"/>. It will return first good place in <paramref name="plantSpawnPos"/> output parameter. No space or capacity will be used if check fail. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.TryFindGoodPlace(System.Collections.Generic.List{Eco.Shared.Math.Vector3i},System.Boolean,Eco.Simulation.Types.PlantSpecies,System.Collections.Generic.List{Eco.Simulation.Agents.Tree},Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Tries to find good place for <paramref name="plantSpecies"/> for one of <paramref name="spaces"/>. If succeed returns <c>true</c> and found place as <paramref name="goodPlace"/>.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.Pushers.PlantSpawner.PostWorldGenPush(Eco.Shared.Math.WorldArea,System.Single[],Eco.Simulation.WorldLayers.WorldLayerNeighborInfo[],System.Int32)">
            <inheritdoc cref="M:Eco.Simulation.WorldLayers.IPostWorldGenWorldLayerPusher.PostWorldGenPush(Eco.Shared.Math.WorldArea,System.Single[],Eco.Simulation.WorldLayers.WorldLayerNeighborInfo[],System.Int32)"/>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.WorldLayerInteraction`1">
            <summary>
            Models an effect that a set of layers have on another layer, e.g. animals eating plants for food kills plants.
            </summary>
        </member>
        <member name="P:Eco.Simulation.WorldLayers.WorldLayerInteraction`1.RequiresNeighborhood">
            <summary> Should be set if the interaction requires <see cref="T:Eco.Simulation.WorldLayers.WorldLayerNeighborInfo"/> for layer values. By default <c>false</c> for optimization purposes. </summary>
        </member>
        <member name="P:Eco.Simulation.WorldLayers.WorldLayerManager.WebLayersDirty">
            <summary> Special flag to recache web layers. For performance reasons. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerManager.PostWorldGenPlants">
            <summary> Called as post world gen step to sync plants state, cleanup dead plants (should ever be?) and randomize they ages. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerManager.PostWorldGenClimateSim">
            <summary> Called as post world gen step to setup climate simulation properties for generated world. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerManager.UpdateLayerVisibility(Eco.Simulation.WorldLayers.Layers.WorldLayer,System.Boolean)">
            <summary> Sets layer visibility and triggers proper on changed events. So it will be reflected to web and client </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerManager.BeginTick">
            <summary> Tries to start World Layer manager tick. Usually used inside of <see cref="M:Eco.Simulation.WorldLayers.WorldLayerManager.Tick"/>, but also may be used by post world gen stuff. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerManager.EndTick">
            <summary> Ends World Layer Manager tick previously started by <see cref="M:Eco.Simulation.WorldLayers.WorldLayerManager.BeginTick"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerManager.SetLayerPushPullActive(System.String,System.Boolean)">
            <summary> Sets the PushPullActive state for a layer, enabling or disabling its activity. </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.WorldLayerUtils">
            <summary>Contains a set of utility methods for WorldLayers.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerUtils.IsInBiome(Eco.Shared.Math.Vector2i,Eco.Shared.States.BiomeType,System.Single)">
            <summary>Returns whether the given position is in a given biome.</summary>
            <param name="margin">optional, describes how much overlap the position needs to have with the biome to be considered in the biome.</param>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerUtils.CapAboveSeaLevel(Eco.Shared.Math.Vector3i)">
            <summary>Return a position with Y above sea level if this is under it or at it.</summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.WorldLayerPuller`1">
            <summary>
            Modifies a world layer based on the state of the world and events since the last tick, e.g. adjusts animal population based on player hunting activity.
            </summary>
        </member>
        <member name="T:Eco.Simulation.WorldLayers.WorldLayerPusher`1">
            <summary>
            Modifies the world to reflect the state of the world layer simulation, e.g. spawns and kills animals to make the population match.
            </summary>
        </member>
        <member name="P:Eco.Simulation.WorldLayers.WorldLayerPusher`1.DependencyLayerNames">
            <summary>Layer names which should be used to populate layerValues for <see cref="M:Eco.Simulation.WorldLayers.WorldLayerPusher`1.Apply(Eco.Shared.Math.WorldArea,System.Single[],Eco.Simulation.WorldLayers.WorldLayerNeighborInfo[],System.Int32)"/>.</summary>
        </member>
        <member name="M:Eco.Simulation.WorldLayers.WorldLayerSync.UpdateLayerTotals(Eco.Simulation.WorldLayers.Layers.WorldLayer)">
            <summary>Recalculates and updates the totals for a specific world layer</summary>
        </member>
        <member name="M:Eco.Simulation.PlantSim.EnumerableOfArea(Eco.Shared.Math.WorldArea,Eco.Simulation.Types.PlantSpecies)">
            <summary> Use this as low-memory allocation option for iterating over plants in area. Internally it will use a lock and pooled list to get plants and release the pooled list in the end of iteration.
            Can be used with linq methods, like Sum, but HyperLinq is prefered since it won't create allocations. </summary>
        </member>
        <member name="M:Eco.Simulation.PlantSim.KillPlant(Eco.Simulation.Agents.Plant,Eco.Simulation.DeathType,System.Boolean)">
            <summary> Turn the plant into a gross dead version. Leave the block and the plant entry.</summary>
        </member>
        <member name="M:Eco.Simulation.PlantSim.TotalFertility(Eco.Shared.Math.WorldArea,System.Boolean)">
            <summary> Calculates total fertility over <paramref name="worldArea"/>. Either for ground or <paramref name="underwater"/> blocks. </summary>
        </member>
        <member name="M:Eco.Simulation.PlantSim.PlantsInBounds(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2)">
            <summary>Enumerates plants in bounds specified by center point and extents.</summary>
        </member>
        <member name="M:Eco.Simulation.Settings.ClimateSettings.OnParamsUpdated">
            <summary> This method called when config changed and recalculates dynamic values. </summary>
        </member>
        <member name="M:Eco.Simulation.Simulation.QueueElementUpdate(Eco.Simulation.Agents.ITickable)">
            <summary> Queue an update to an element. Updates are applied on <see cref="M:Eco.Simulation.Simulation.TickAll(System.Int32)"/> or <see cref="M:Eco.Simulation.Simulation.GetNextSmallestTickSeconds"/> </summary>
        </member>
        <member name="P:Eco.Simulation.Types.AnimalSpecies.TimeTill50PercentCloserToMaxInHours">
            <summary>How long it takes the population to rise 50% closer to the max in its cell.</summary>
        </member>
        <member name="P:Eco.Simulation.Types.AnimalSpecies.TimeToSpread1ToNeighborInHours">
            <summary>How many hours it takes to reach 1 organism from 0 in a neighboring cell.</summary>
        </member>
        <member name="P:Eco.Simulation.Types.AnimalSpecies.MaxGrowthRatePerHour">
            <summary>Caps total growth rate, both population increase and spread</summary>
        </member>
        <member name="T:Eco.Simulation.Types.PlantGroupDefinition">
            <summary> Contains configuration of plants grouping. 
            Grouping consists in two phases: 
            1) Generation of "CountOfClusters" clusters. Cluster - most populated areas in the world. 
            2) Each cluster will be populated with groups of plants. You can't control directly the number of groups, but you can control how far one to other they will be spawned. </summary>
        </member>
        <member name="M:Eco.Simulation.Types.PlantSpecies.ResourceConstraint.Habitability(System.Single)">
            <summary> Calculates habitability for this resource constraint for given <paramref name="resourceConcentration"/>. </summary>
        </member>
        <member name="M:Eco.Simulation.Types.PlantSpecies.CapacityConstraint.Habitability(System.Single)">
            <summary> Calculates habitability for given <paramref name="capacity"/>. It is based on <see cref="P:Eco.Simulation.Types.PlantSpecies.CapacityConstraint.ConsumedCapacityPerPop"/>. <paramref name="capacity"/> is density per voxel column. </summary>
        </member>
        <member name="M:Eco.Simulation.Types.PlantSpecies.CapacityConstraint.GrowthRate(System.Single,System.Single)">
            <summary> Calculates growth rate in range [0; 1]. It then can be used in formula N + N * growthRate to get new population size. </summary>
        </member>
        <member name="M:Eco.Simulation.Types.PlantSpecies.GetMostCrowdedSpaceUsed(Eco.Simulation.WorldLayers.Layers.LayerPosition)">
            <summary> Calculate how much space crowded in an area with the plant based on habitability modifier. </summary>
        </member>
        <member name="M:Eco.Simulation.Types.PlantSpecies.IsGoodPlacement(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary>Checks if <paramref name="placementPosition"/> is good for that plant species.</summary>
        </member>
        <member name="P:Eco.Simulation.Types.TreeSpecies.SequentialBranchRotations">
            <summary>When set will use the branch rotations in order instead of randomly, useful for putting branches at the same height in a circle around the tree.</summary>
        </member>
        <member name="M:Eco.WorldGenerator.EcoColorExtensions.ToSharpNoiseColor(Eco.Shared.Utils.Color)">
            <summary>Converts 'Eco.Shared.Utils.Color' to 'SharpNoise.Utilities.Imaging.Color'</summary>
        </member>
        <member name="F:Eco.WorldGenerator.WorldLayerPanel.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:Eco.WorldGenerator.WorldLayerPanel.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Eco.WorldGenerator.WorldLayerPanel.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
    </members>
</doc>
